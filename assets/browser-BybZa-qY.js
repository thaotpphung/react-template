var Pe=Object.defineProperty;var Te=(e,t,r)=>t in e?Pe(e,t,{enumerable:!0,configurable:!0,writable:!0,value:r}):e[t]=r;var R=(e,t,r)=>(Te(e,typeof t!="symbol"?t+"":t,r),r),$=(e,t,r)=>{if(!t.has(e))throw TypeError("Cannot "+r)};var _=(e,t,r)=>($(e,t,"read from private field"),r?r.call(e):t.get(e)),F=(e,t,r)=>{if(t.has(e))throw TypeError("Cannot add the same private member more than once");t instanceof WeakSet?t.add(e):t.set(e,r)},Q=(e,t,r,s)=>($(e,t,"write to private field"),s?s.call(e,r):t.set(e,r),r);var C=(e,t,r)=>($(e,t,"access private method"),r);import{S as Ae,d as b,h as ue,R as je,a as xe,b as h,c as g,H as l,p as L}from"./db-CKDckAKK.js";import{e as m}from"./index-BzG1M9g9.js";function _e(e){return{status:e.status,statusText:e.statusText,headers:Object.fromEntries(e.headers.entries())}}function Z(e){return e!=null&&typeof e=="object"&&!Array.isArray(e)}function le(e,t){return Object.entries(t).reduce((r,[s,n])=>{const i=r[s];return Array.isArray(i)&&Array.isArray(n)?(r[s]=i.concat(n),r):Z(i)&&Z(n)?(r[s]=le(i,n),r):(r[s]=n,r)},Object.assign({},e))}var Me={},Oe=/(%?)(%([sdijo]))/g;function Ce(e,t){switch(t){case"s":return e;case"d":case"i":return Number(e);case"j":return JSON.stringify(e);case"o":{if(typeof e=="string")return e;const r=JSON.stringify(e);return r==="{}"||r==="[]"||/^\[object .+?\]$/.test(r)?e:r}}}function O(e,...t){if(t.length===0)return e;let r=0,s=e.replace(Oe,(n,i,o,a)=>{const c=t[r],u=Ce(c,a);return i?n:(r++,u)});return r<t.length&&(s+=` ${t.slice(r).join(" ")}`),s=s.replace(/%{2,2}/g,"%"),s}var He=2;function Ue(e){if(!e.stack)return;const t=e.stack.split(`
`);t.splice(1,He),e.stack=t.join(`
`)}var We=class extends Error{constructor(e,...t){super(e),this.message=e,this.name="Invariant Violation",this.message=O(e,...t),Ue(this)}},P=(e,t,...r)=>{if(!e)throw new We(t,...r)};P.as=(e,t,r,...s)=>{if(!t){const n=s.length===0?r:O(r,s);let i;try{i=Reflect.construct(e,[n])}catch{i=e(n)}throw i}};function z(){if(typeof navigator<"u"&&navigator.product==="ReactNative")return!0;if(typeof process<"u"){const e=process.type;return e==="renderer"||e==="worker"?!1:!!(process.versions&&process.versions.node)}return!1}var J=async e=>{try{return{error:null,data:await e().catch(r=>{throw r})}}catch(t){return{error:t,data:null}}};function De(e){return new URL(e,location.href).href}function N(e,t,r){return[e.active,e.installing,e.waiting].filter(o=>o!=null).find(o=>r(o.scriptURL,t))||null}var Be=async(e,t={},r)=>{const s=De(e),n=await navigator.serviceWorker.getRegistrations().then(a=>a.filter(c=>N(c,s,r)));!navigator.serviceWorker.controller&&n.length>0&&location.reload();const[i]=n;if(i)return i.update().then(()=>[N(i,s,r),i]);const o=await J(async()=>{const a=await navigator.serviceWorker.register(e,t);return[N(a,s,r),a]});if(o.error){if(o.error.message.includes("(404)")){const c=new URL((t==null?void 0:t.scope)||"/",location.href);throw new Error(b.formatMessage(`Failed to register a Service Worker for scope ('${c.href}') with script ('${s}'): Service Worker script does not exist at the given path.

Did you forget to run "npx msw init <PUBLIC_DIR>"?

Learn more about creating the Service Worker script: https://mswjs.io/docs/cli/init`))}throw new Error(b.formatMessage(`Failed to register the Service Worker:

%s`,o.error.message))}return o.data};function de(e={}){if(e.quiet)return;const t=e.message||"Mocking enabled.";console.groupCollapsed(`%c${b.formatMessage(t)}`,"color:orangered;font-weight:bold;"),console.log("%cDocumentation: %chttps://mswjs.io/docs","font-weight:bold","font-weight:normal"),console.log("Found an issue? https://github.com/mswjs/msw/issues"),e.workerUrl&&console.log("Worker script URL:",e.workerUrl),e.workerScope&&console.log("Worker scope:",e.workerScope),console.groupEnd()}async function $e(e,t){var r,s;if(e.workerChannel.send("MOCK_ACTIVATE"),await e.events.once("MOCKING_ENABLED"),e.isMockingEnabled){b.warn('Found a redundant "worker.start()" call. Note that starting the worker while mocking is already enabled will have no effect. Consider removing this "worker.start()" call.');return}e.isMockingEnabled=!0,de({quiet:t.quiet,workerScope:(r=e.registration)==null?void 0:r.scope,workerUrl:(s=e.worker)==null?void 0:s.scriptURL})}var Fe=class{constructor(e){this.port=e}postMessage(e,...t){const[r,s]=t;this.port.postMessage({type:e,data:r},{transfer:s})}};function Ne(e){if(!["HEAD","GET"].includes(e.method))return e.body}function Ge(e){return new Request(e.url,{...e,body:Ne(e)})}var Xe=(e,t)=>async(r,s)=>{const n=new Fe(r.ports[0]),i=s.payload.id,o=Ge(s.payload),a=o.clone(),c=o.clone();je.cache.set(o,c),e.requests.set(i,c);try{await ue(o,i,e.getRequestHandlers(),t,e.emitter,{onPassthroughResponse(){n.postMessage("PASSTHROUGH")},async onMockedResponse(u,{handler:d,parsedResult:p}){const f=u.clone(),w=u.clone(),v=_e(u);if(e.supports.readableStreamTransfer){const E=u.body;n.postMessage("MOCK_RESPONSE",{...v,body:E},E?[E]:void 0)}else{const E=u.body===null?null:await f.arrayBuffer();n.postMessage("MOCK_RESPONSE",{...v,body:E})}t.quiet||e.emitter.once("response:mocked",()=>{d.log({request:a,response:w,parsedResult:p})})}})}catch(u){u instanceof Error&&(b.error(`Uncaught exception in the request handler for "%s %s":

%s

This exception has been gracefully handled as a 500 response, however, it's strongly recommended to resolve this error, as it indicates a mistake in your code. If you wish to mock an error response, please see this guide: https://mswjs.io/docs/recipes/mocking-error-responses`,o.method,o.url,u.stack??u),n.postMessage("MOCK_RESPONSE",{status:500,statusText:"Request Handler Error",headers:{"Content-Type":"application/json"},body:JSON.stringify({name:u.name,message:u.message,stack:u.stack})}))}};async function Ve(e){e.workerChannel.send("INTEGRITY_CHECK_REQUEST");const{payload:t}=await e.events.once("INTEGRITY_CHECK_RESPONSE");t.checksum!=="26357c79639bfa20d64c0efca2a87423"&&b.warn(`The currently registered Service Worker has been generated by a different version of MSW (${t.packageVersion}) and may not be fully compatible with the installed version.

It's recommended you update your worker script by running this command:

  • npx msw init <PUBLIC_DIR>

You can also automate this process and make the worker script update automatically upon the library installations. Read more: https://mswjs.io/docs/cli/init.`)}var Ke=new TextEncoder;function ze(e){return Ke.encode(e)}function Je(e,t){return new TextDecoder(t).decode(e)}function Ye(e){return e.buffer.slice(e.byteOffset,e.byteOffset+e.byteLength)}var Qe=new Set([101,103,204,205,304]);function he(e){return Qe.has(e)}var A=Symbol("isPatchedModule"),Ze=Object.defineProperty,et=(e,t)=>{for(var r in t)Ze(e,r,{get:t[r],enumerable:!0})},G={};et(G,{blue:()=>rt,gray:()=>X,green:()=>nt,red:()=>st,yellow:()=>tt});function tt(e){return`\x1B[33m${e}\x1B[0m`}function rt(e){return`\x1B[34m${e}\x1B[0m`}function X(e){return`\x1B[90m${e}\x1B[0m`}function st(e){return`\x1B[31m${e}\x1B[0m`}function nt(e){return`\x1B[32m${e}\x1B[0m`}var B=z(),fe=class{constructor(e){R(this,"prefix");this.name=e,this.prefix=`[${this.name}]`;const t=ee("DEBUG"),r=ee("LOG_LEVEL");t==="1"||t==="true"||typeof t<"u"&&this.name.startsWith(t)?(this.debug=M(r,"debug")?k:this.debug,this.info=M(r,"info")?k:this.info,this.success=M(r,"success")?k:this.success,this.warning=M(r,"warning")?k:this.warning,this.error=M(r,"error")?k:this.error):(this.info=k,this.success=k,this.warning=k,this.error=k,this.only=k)}extend(e){return new fe(`${this.name}:${e}`)}debug(e,...t){this.logEntry({level:"debug",message:X(e),positionals:t,prefix:this.prefix,colors:{prefix:"gray"}})}info(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:this.prefix,colors:{prefix:"blue"}});const r=new ot;return(s,...n)=>{r.measure(),this.logEntry({level:"info",message:`${s} ${X(`${r.deltaTime}ms`)}`,positionals:n,prefix:this.prefix,colors:{prefix:"blue"}})}}success(e,...t){this.logEntry({level:"info",message:e,positionals:t,prefix:`✔ ${this.prefix}`,colors:{timestamp:"green",prefix:"green"}})}warning(e,...t){this.logEntry({level:"warning",message:e,positionals:t,prefix:`⚠ ${this.prefix}`,colors:{timestamp:"yellow",prefix:"yellow"}})}error(e,...t){this.logEntry({level:"error",message:e,positionals:t,prefix:`✖ ${this.prefix}`,colors:{timestamp:"red",prefix:"red"}})}only(e){e()}createEntry(e,t){return{timestamp:new Date,level:e,message:t}}logEntry(e){const{level:t,message:r,prefix:s,colors:n,positionals:i=[]}=e,o=this.createEntry(t,r),a=(n==null?void 0:n.timestamp)||"gray",c=(n==null?void 0:n.prefix)||"gray",u={timestamp:G[a],prefix:G[c]};this.getWriter(t)([u.timestamp(this.formatTimestamp(o.timestamp))].concat(s!=null?u.prefix(s):[]).concat(te(r)).join(" "),...i.map(te))}formatTimestamp(e){return`${e.toLocaleTimeString("en-GB")}:${e.getMilliseconds()}`}getWriter(e){switch(e){case"debug":case"success":case"info":return it;case"warning":return at;case"error":return ct}}},ot=class{constructor(){R(this,"startTime");R(this,"endTime");R(this,"deltaTime");this.startTime=performance.now()}measure(){this.endTime=performance.now();const e=this.endTime-this.startTime;this.deltaTime=e.toFixed(2)}},k=()=>{};function it(e,...t){if(B){process.stdout.write(O(e,...t)+`
`);return}console.log(e,...t)}function at(e,...t){if(B){process.stderr.write(O(e,...t)+`
`);return}console.warn(e,...t)}function ct(e,...t){if(B){process.stderr.write(O(e,...t)+`
`);return}console.error(e,...t)}function ee(e){var t;return B?Me[e]:(t=globalThis[e])==null?void 0:t.toString()}function M(e,t){return e!==void 0&&e!==t}function te(e){return typeof e>"u"?"undefined":e===null?"null":typeof e=="string"?e:typeof e=="object"?JSON.stringify(e):e.toString()}var ut=class extends Error{constructor(e,t,r){super(`Possible EventEmitter memory leak detected. ${r} ${t.toString()} listeners added. Use emitter.setMaxListeners() to increase limit`),this.emitter=e,this.type=t,this.count=r,this.name="MaxListenersExceededWarning"}},pe=class{static listenerCount(e,t){return e.listenerCount(t)}constructor(){this.events=new Map,this.maxListeners=pe.defaultMaxListeners,this.hasWarnedAboutPotentialMemoryLeak=!1}_emitInternalEvent(e,t,r){this.emit(e,t,r)}_getListeners(e){return Array.prototype.concat.apply([],this.events.get(e))||[]}_removeListener(e,t){const r=e.indexOf(t);return r>-1&&e.splice(r,1),[]}_wrapOnceListener(e,t){const r=(...s)=>(this.removeListener(e,r),t.apply(this,s));return Object.defineProperty(r,"name",{value:t.name}),r}setMaxListeners(e){return this.maxListeners=e,this}getMaxListeners(){return this.maxListeners}eventNames(){return Array.from(this.events.keys())}emit(e,...t){const r=this._getListeners(e);return r.forEach(s=>{s.apply(this,t)}),r.length>0}addListener(e,t){this._emitInternalEvent("newListener",e,t);const r=this._getListeners(e).concat(t);if(this.events.set(e,r),this.maxListeners>0&&this.listenerCount(e)>this.maxListeners&&!this.hasWarnedAboutPotentialMemoryLeak){this.hasWarnedAboutPotentialMemoryLeak=!0;const s=new ut(this,e,this.listenerCount(e));console.warn(s)}return this}on(e,t){return this.addListener(e,t)}once(e,t){return this.addListener(e,this._wrapOnceListener(e,t))}prependListener(e,t){const r=this._getListeners(e);if(r.length>0){const s=[t].concat(r);this.events.set(e,s)}else this.events.set(e,r.concat(t));return this}prependOnceListener(e,t){return this.prependListener(e,this._wrapOnceListener(e,t))}removeListener(e,t){const r=this._getListeners(e);return r.length>0&&(this._removeListener(r,t),this.events.set(e,r),this._emitInternalEvent("removeListener",e,t)),this}off(e,t){return this.removeListener(e,t)}removeAllListeners(e){return e?this.events.delete(e):this.events.clear(),this}listeners(e){return Array.from(this._getListeners(e))}listenerCount(e){return this._getListeners(e).length}rawListeners(e){return this.listeners(e)}},ge=pe;ge.defaultMaxListeners=10;var lt="x-interceptors-internal-request-id";function re(e){return globalThis[e]||void 0}function dt(e,t){globalThis[e]=t}function ht(e){delete globalThis[e]}var Y=class{constructor(e){this.symbol=e,this.readyState="INACTIVE",this.emitter=new ge,this.subscriptions=[],this.logger=new fe(e.description),this.emitter.setMaxListeners(0),this.logger.info("constructing the interceptor...")}checkEnvironment(){return!0}apply(){const e=this.logger.extend("apply");if(e.info("applying the interceptor..."),this.readyState==="APPLIED"){e.info("intercepted already applied!");return}if(!this.checkEnvironment()){e.info("the interceptor cannot be applied in this environment!");return}this.readyState="APPLYING";const r=this.getInstance();if(r){e.info("found a running instance, reusing..."),this.on=(s,n)=>(e.info('proxying the "%s" listener',s),r.emitter.addListener(s,n),this.subscriptions.push(()=>{r.emitter.removeListener(s,n),e.info('removed proxied "%s" listener!',s)}),this),this.readyState="APPLIED";return}e.info("no running instance found, setting up a new instance..."),this.setup(),this.setInstance(),this.readyState="APPLIED"}setup(){}on(e,t){const r=this.logger.extend("on");return this.readyState==="DISPOSING"||this.readyState==="DISPOSED"?(r.info("cannot listen to events, already disposed!"),this):(r.info('adding "%s" event listener:',e,t),this.emitter.on(e,t),this)}once(e,t){return this.emitter.once(e,t),this}off(e,t){return this.emitter.off(e,t),this}removeAllListeners(e){return this.emitter.removeAllListeners(e),this}dispose(){const e=this.logger.extend("dispose");if(this.readyState==="DISPOSED"){e.info("cannot dispose, already disposed!");return}if(e.info("disposing the interceptor..."),this.readyState="DISPOSING",!this.getInstance()){e.info("no interceptors running, skipping dispose...");return}if(this.clearInstance(),e.info("global symbol deleted:",re(this.symbol)),this.subscriptions.length>0){e.info("disposing of %d subscriptions...",this.subscriptions.length);for(const t of this.subscriptions)t();this.subscriptions=[],e.info("disposed of all subscriptions!",this.subscriptions.length)}this.emitter.removeAllListeners(),e.info("destroyed the listener!"),this.readyState="DISPOSED"}getInstance(){var e;const t=re(this.symbol);return this.logger.info("retrieved global instance:",(e=t==null?void 0:t.constructor)==null?void 0:e.name),t}setInstance(){dt(this.symbol,this),this.logger.info("set global instance!",this.symbol.description)}clearInstance(){ht(this.symbol),this.logger.info("cleared global instance!",this.symbol.description)}};function me(){return Math.random().toString(16).slice(2)}var V=class extends Y{constructor(e){V.symbol=Symbol(e.name),super(V.symbol),this.interceptors=e.interceptors}setup(){const e=this.logger.extend("setup");e.info("applying all %d interceptors...",this.interceptors.length);for(const t of this.interceptors)e.info('applying "%s" interceptor...',t.constructor.name),t.apply(),e.info("adding interceptor dispose subscription"),this.subscriptions.push(()=>t.dispose())}on(e,t){for(const r of this.interceptors)r.on(e,t);return this}once(e,t){for(const r of this.interceptors)r.once(e,t);return this}off(e,t){for(const r of this.interceptors)r.off(e,t);return this}removeAllListeners(e){for(const t of this.interceptors)t.removeAllListeners(e);return this}};function ft(e){return(t,r)=>{var a;const{payload:s}=r,{requestId:n}=s,i=e.requests.get(n);if(e.requests.delete(n),(a=s.type)!=null&&a.includes("opaque"))return;const o=s.status===0?Response.error():new Response(he(s.status)?null:s.body,s);o.url||Object.defineProperty(o,"url",{value:i.url,enumerable:!0,writable:!1}),e.emitter.emit(s.isMockedResponse?"response:mocked":"response:bypass",{response:o,request:i,requestId:s.requestId})}}function pt(e,t){!(t!=null&&t.quiet)&&!location.href.startsWith(e.scope)&&b.warn(`Cannot intercept requests on this page because it's outside of the worker's scope ("${e.scope}"). If you wish to mock API requests on this page, you must resolve this scope issue.

- (Recommended) Register the worker at the root level ("/") of your application.
- Set the "Service-Worker-Allowed" response header to allow out-of-scope workers.`)}var gt=e=>function(r,s){return(async()=>{e.events.removeAllListeners(),e.workerChannel.on("REQUEST",Xe(e,r)),e.workerChannel.on("RESPONSE",ft(e));const o=await Be(r.serviceWorker.url,r.serviceWorker.options,r.findWorker),[a,c]=o;if(!a){const u=s!=null&&s.findWorker?b.formatMessage(`Failed to locate the Service Worker registration using a custom "findWorker" predicate.

Please ensure that the custom predicate properly locates the Service Worker registration at "%s".
More details: https://mswjs.io/docs/api/setup-worker/start#findworker
`,r.serviceWorker.url):b.formatMessage(`Failed to locate the Service Worker registration.

This most likely means that the worker script URL "%s" cannot resolve against the actual public hostname (%s). This may happen if your application runs behind a proxy, or has a dynamic hostname.

Please consider using a custom "serviceWorker.url" option to point to the actual worker script location, or a custom "findWorker" option to resolve the Service Worker registration manually. More details: https://mswjs.io/docs/api/setup-worker/start`,r.serviceWorker.url,location.host);throw new Error(u)}return e.worker=a,e.registration=c,e.events.addListener(window,"beforeunload",()=>{a.state!=="redundant"&&e.workerChannel.send("CLIENT_CLOSED"),window.clearInterval(e.keepAliveInterval)}),await Ve(e).catch(u=>{b.error("Error while checking the worker script integrity. Please report this on GitHub (https://github.com/mswjs/msw/issues), including the original error below."),console.error(u)}),e.keepAliveInterval=window.setInterval(()=>e.workerChannel.send("KEEPALIVE_REQUEST"),5e3),pt(c,e.startOptions),c})().then(async o=>{const a=o.installing||o.waiting;return a&&await new Promise(c=>{a.addEventListener("statechange",()=>{if(a.state==="activated")return c()})}),await $e(e,r).catch(c=>{throw new Error(`Failed to enable mocking: ${c==null?void 0:c.message}`)}),o})};function ye(e={}){e.quiet||console.log(`%c${b.formatMessage("Mocking disabled.")}`,"color:orangered;font-weight:bold;")}var mt=e=>function(){var r;if(!e.isMockingEnabled){b.warn('Found a redundant "worker.stop()" call. Note that stopping the worker while mocking already stopped has no effect. Consider removing this "worker.stop()" call.');return}e.workerChannel.send("MOCK_DEACTIVATE"),e.isMockingEnabled=!1,window.clearInterval(e.keepAliveInterval),ye({quiet:(r=e.startOptions)==null?void 0:r.quiet})},yt={serviceWorker:{url:"/mockServiceWorker.js",options:null},quiet:!1,waitUntilReady:!0,onUnhandledRequest:"warn",findWorker(e,t){return e===t}};function wt(){const e=(t,r)=>{e.state="pending",e.resolve=s=>{if(e.state!=="pending")return;e.result=s;const n=i=>(e.state="fulfilled",i);return t(s instanceof Promise?s:Promise.resolve(s).then(n))},e.reject=s=>{if(e.state==="pending")return queueMicrotask(()=>{e.state="rejected"}),r(e.rejectionReason=s)}};return e}var S,j,U,ce,we=(ce=class extends Promise{constructor(t=null){const r=wt();super((s,n)=>{r(s,n),t==null||t(r.resolve,r.reject)});F(this,j);F(this,S,void 0);R(this,"resolve");R(this,"reject");Q(this,S,r),this.resolve=_(this,S).resolve,this.reject=_(this,S).reject}get state(){return _(this,S).state}get rejectionReason(){return _(this,S).rejectionReason}then(t,r){return C(this,j,U).call(this,super.then(t,r))}catch(t){return C(this,j,U).call(this,super.catch(t))}finally(t){return C(this,j,U).call(this,super.finally(t))}},S=new WeakMap,j=new WeakSet,U=function(t){return Object.defineProperties(t,{resolve:{configurable:!0,value:this.resolve},reject:{configurable:!0,value:this.reject}})},ce),vt=class{constructor(e){this.request=e,this.responsePromise=new we}respondWith(e){P(this.responsePromise.state==="pending",'Failed to respond to "%s %s" request: the "request" event has already been responded to.',this.request.method,this.request.url),this.responsePromise.resolve(e)}};function ve(e){const t=new vt(e);return Reflect.set(e,"respondWith",t.respondWith.bind(t)),{interactiveRequest:e,requestController:t}}async function be(e,t,...r){const s=e.listeners(t);if(s.length!==0)for(const n of s)await n.apply(e,r)}function bt(e,t){try{return e[t],!0}catch{return!1}}function qt(e){try{return new URL(e),!0}catch{return!1}}var qe=class extends Y{constructor(){super(qe.symbol)}checkEnvironment(){return typeof globalThis<"u"&&typeof globalThis.fetch<"u"}async setup(){const e=globalThis.fetch;P(!e[A],'Failed to patch the "fetch" module: already patched.'),globalThis.fetch=async(t,r)=>{var s;const n=me(),i=typeof t=="string"&&typeof location<"u"&&!qt(t)?new URL(t,location.origin):t,o=new Request(i,r);this.logger.info("[%s] %s",o.method,o.url);const{interactiveRequest:a,requestController:c}=ve(o);this.logger.info('emitting the "request" event for %d listener(s)...',this.emitter.listenerCount("request")),this.emitter.once("request",({requestId:w})=>{w===n&&c.responsePromise.state==="pending"&&c.responsePromise.resolve(void 0)}),this.logger.info("awaiting for the mocked response...");const u=a.signal,d=new we;u&&u.addEventListener("abort",()=>{d.reject(u.reason)},{once:!0});const p=await J(async()=>{const w=be(this.emitter,"request",{request:a,requestId:n});await Promise.race([d,w,c.responsePromise]),this.logger.info("all request listeners have been resolved!");const v=await c.responsePromise;return this.logger.info("event.respondWith called with:",v),v});if(d.state==="rejected")return Promise.reject(d.rejectionReason);if(p.error)return Promise.reject(se(p.error));const f=p.data;if(f&&!((s=o.signal)!=null&&s.aborted)){if(this.logger.info("received mocked response:",f),bt(f,"type")&&f.type==="error")return this.logger.info("received a network error response, rejecting the request promise..."),Promise.reject(se(f));const w=f.clone();return this.emitter.emit("response",{response:w,isMockedResponse:!0,request:a,requestId:n}),Object.defineProperty(f,"url",{writable:!1,enumerable:!0,configurable:!1,value:o.url}),f}return this.logger.info("no mocked response received!"),e(o).then(w=>{const v=w.clone();return this.logger.info("original fetch performed",v),this.emitter.emit("response",{response:v,isMockedResponse:!1,request:a,requestId:n}),w})},Object.defineProperty(globalThis.fetch,A,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.fetch,A,{value:void 0}),globalThis.fetch=e,this.logger.info('restored native "globalThis.fetch"!',globalThis.fetch.name)})}},Re=qe;Re.symbol=Symbol("fetch");function se(e){return Object.assign(new TypeError("Failed to fetch"),{cause:e})}function Rt(e,t){const r=new Uint8Array(e.byteLength+t.byteLength);return r.set(e,0),r.set(t,e.byteLength),r}var Ee=class{constructor(e,t){this.AT_TARGET=0,this.BUBBLING_PHASE=0,this.CAPTURING_PHASE=0,this.NONE=0,this.type="",this.srcElement=null,this.currentTarget=null,this.eventPhase=0,this.isTrusted=!0,this.composed=!1,this.cancelable=!0,this.defaultPrevented=!1,this.bubbles=!0,this.lengthComputable=!0,this.loaded=0,this.total=0,this.cancelBubble=!1,this.returnValue=!0,this.type=e,this.target=(t==null?void 0:t.target)||null,this.currentTarget=(t==null?void 0:t.currentTarget)||null,this.timeStamp=Date.now()}composedPath(){return[]}initEvent(e,t,r){this.type=e,this.bubbles=!!t,this.cancelable=!!r}preventDefault(){this.defaultPrevented=!0}stopPropagation(){}stopImmediatePropagation(){}},Et=class extends Ee{constructor(e,t){super(e),this.lengthComputable=(t==null?void 0:t.lengthComputable)||!1,this.composed=(t==null?void 0:t.composed)||!1,this.loaded=(t==null?void 0:t.loaded)||0,this.total=(t==null?void 0:t.total)||0}},kt=typeof ProgressEvent<"u";function Lt(e,t,r){const s=["error","progress","loadstart","loadend","load","timeout","abort"],n=kt?ProgressEvent:Et;return s.includes(t)?new n(t,{lengthComputable:!0,loaded:(r==null?void 0:r.loaded)||0,total:(r==null?void 0:r.total)||0}):new Ee(t,{target:e,currentTarget:e})}function ke(e,t){if(!(t in e))return null;if(Object.prototype.hasOwnProperty.call(e,t))return e;const s=Reflect.getPrototypeOf(e);return s?ke(s,t):null}function ne(e,t){return new Proxy(e,It(t))}function It(e){const{constructorCall:t,methodCall:r,getProperty:s,setProperty:n}=e,i={};return typeof t<"u"&&(i.construct=function(o,a,c){const u=Reflect.construct.bind(null,o,a,c);return t.call(c,a,u)}),i.set=function(o,a,c){const u=()=>{const d=ke(o,a)||o,p=Reflect.getOwnPropertyDescriptor(d,a);return typeof(p==null?void 0:p.set)<"u"?(p.set.apply(o,[c]),!0):Reflect.defineProperty(d,a,{writable:!0,enumerable:!0,configurable:!0,value:c})};return typeof n<"u"?n.call(o,[a,c],u):u()},i.get=function(o,a,c){const u=()=>o[a],d=typeof s<"u"?s.call(o,[a,c],u):u();return typeof d=="function"?(...p)=>{const f=d.bind(o,...p);return typeof r<"u"?r.call(o,[a,p],f):f()}:d},i}function St(e){return["application/xhtml+xml","application/xml","image/svg+xml","text/html","text/xml"].some(r=>e.startsWith(r))}function Pt(e){try{return JSON.parse(e)}catch{return null}}function Tt(e,t){const r=he(e.status)?null:t;return new Response(r,{status:e.status,statusText:e.statusText,headers:At(e.getAllResponseHeaders())})}function At(e){const t=new Headers,r=e.split(/[\r\n]+/);for(const s of r){if(s.trim()==="")continue;const[n,...i]=s.split(": "),o=i.join(": ");t.append(n,o)}return t}var oe=Symbol("isMockedResponse"),jt=z(),xt=class{constructor(e,t){this.initialRequest=e,this.logger=t,this.method="GET",this.url=null,this.events=new Map,this.requestId=me(),this.requestHeaders=new Headers,this.responseBuffer=new Uint8Array,this.request=ne(e,{setProperty:([r,s],n)=>{switch(r){case"ontimeout":{const i=r.slice(2);return this.request.addEventListener(i,s),n()}default:return n()}},methodCall:([r,s],n)=>{var i;switch(r){case"open":{const[o,a]=s;return typeof a>"u"?(this.method="GET",this.url=ie(o)):(this.method=o,this.url=ie(a)),this.logger=this.logger.extend(`${this.method} ${this.url.href}`),this.logger.info("open",this.method,this.url.href),n()}case"addEventListener":{const[o,a]=s;return this.registerEvent(o,a),this.logger.info("addEventListener",o,a),n()}case"setRequestHeader":{const[o,a]=s;return this.requestHeaders.set(o,a),this.logger.info("setRequestHeader",o,a),n()}case"send":{const[o]=s;o!=null&&(this.requestBody=typeof o=="string"?ze(o):o),this.request.addEventListener("load",()=>{if(typeof this.onResponse<"u"){const u=Tt(this.request,this.request.response);this.onResponse.call(this,{response:u,isMockedResponse:oe in this.request,request:a,requestId:this.requestId})}});const a=this.toFetchApiRequest();(((i=this.onRequest)==null?void 0:i.call(this,{request:a,requestId:this.requestId}))||Promise.resolve()).finally(()=>{if(this.request.readyState<this.request.LOADING)return this.logger.info("request callback settled but request has not been handled (readystate %d), performing as-is...",this.request.readyState),jt&&this.request.setRequestHeader(lt,this.requestId),n()});break}default:return n()}}})}registerEvent(e,t){const s=(this.events.get(e)||[]).concat(t);this.events.set(e,s),this.logger.info('registered event "%s"',e,t)}respondWith(e){this.logger.info("responding with a mocked response: %d %s",e.status,e.statusText),T(this.request,oe,!0),T(this.request,"status",e.status),T(this.request,"statusText",e.statusText),T(this.request,"responseURL",this.url.href),this.request.getResponseHeader=new Proxy(this.request.getResponseHeader,{apply:(s,n,i)=>{if(this.logger.info("getResponseHeader",i[0]),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning null"),null;const o=e.headers.get(i[0]);return this.logger.info('resolved response header "%s" to',i[0],o),o}}),this.request.getAllResponseHeaders=new Proxy(this.request.getAllResponseHeaders,{apply:()=>{if(this.logger.info("getAllResponseHeaders"),this.request.readyState<this.request.HEADERS_RECEIVED)return this.logger.info("headers not received yet, returning empty string"),"";const n=Array.from(e.headers.entries()).map(([i,o])=>`${i}: ${o}`).join(`\r
`);return this.logger.info("resolved all response headers to",n),n}}),Object.defineProperties(this.request,{response:{enumerable:!0,configurable:!1,get:()=>this.response},responseText:{enumerable:!0,configurable:!1,get:()=>this.responseText},responseXML:{enumerable:!0,configurable:!1,get:()=>this.responseXML}});const t=e.headers.has("Content-Length")?Number(e.headers.get("Content-Length")):void 0;this.logger.info("calculated response body length",t),this.trigger("loadstart",{loaded:0,total:t}),this.setReadyState(this.request.HEADERS_RECEIVED),this.setReadyState(this.request.LOADING);const r=()=>{this.logger.info("finalizing the mocked response..."),this.setReadyState(this.request.DONE),this.trigger("load",{loaded:this.responseBuffer.byteLength,total:t}),this.trigger("loadend",{loaded:this.responseBuffer.byteLength,total:t})};if(e.body){this.logger.info("mocked response has body, streaming...");const s=e.body.getReader(),n=async()=>{const{value:i,done:o}=await s.read();if(o){this.logger.info("response body stream done!"),r();return}i&&(this.logger.info("read response body chunk:",i),this.responseBuffer=Rt(this.responseBuffer,i),this.trigger("progress",{loaded:this.responseBuffer.byteLength,total:t})),n()};n()}else r()}responseBufferToText(){return Je(this.responseBuffer)}get response(){if(this.logger.info("getResponse (responseType: %s)",this.request.responseType),this.request.readyState!==this.request.DONE)return null;switch(this.request.responseType){case"json":{const e=Pt(this.responseBufferToText());return this.logger.info("resolved response JSON",e),e}case"arraybuffer":{const e=Ye(this.responseBuffer);return this.logger.info("resolved response ArrayBuffer",e),e}case"blob":{const e=this.request.getResponseHeader("Content-Type")||"text/plain",t=new Blob([this.responseBufferToText()],{type:e});return this.logger.info("resolved response Blob (mime type: %s)",t,e),t}default:{const e=this.responseBufferToText();return this.logger.info('resolving "%s" response type as text',this.request.responseType,e),e}}}get responseText(){if(P(this.request.responseType===""||this.request.responseType==="text","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.LOADING&&this.request.readyState!==this.request.DONE)return"";const e=this.responseBufferToText();return this.logger.info('getResponseText: "%s"',e),e}get responseXML(){if(P(this.request.responseType===""||this.request.responseType==="document","InvalidStateError: The object is in invalid state."),this.request.readyState!==this.request.DONE)return null;const e=this.request.getResponseHeader("Content-Type")||"";return typeof DOMParser>"u"?(console.warn("Cannot retrieve XMLHttpRequest response body as XML: DOMParser is not defined. You are likely using an environment that is not browser or does not polyfill browser globals correctly."),null):St(e)?new DOMParser().parseFromString(this.responseBufferToText(),e):null}errorWith(e){this.logger.info("responding with an error"),this.setReadyState(this.request.DONE),this.trigger("error"),this.trigger("loadend")}setReadyState(e){if(this.logger.info("setReadyState: %d -> %d",this.request.readyState,e),this.request.readyState===e){this.logger.info("ready state identical, skipping transition...");return}T(this.request,"readyState",e),this.logger.info("set readyState to: %d",e),e!==this.request.UNSENT&&(this.logger.info('triggerring "readystatechange" event...'),this.trigger("readystatechange"))}trigger(e,t){const r=this.request[`on${e}`],s=Lt(this.request,e,t);this.logger.info('trigger "%s"',e,t||""),typeof r=="function"&&(this.logger.info('found a direct "%s" callback, calling...',e),r.call(this.request,s));for(const[n,i]of this.events)n===e&&(this.logger.info('found %d listener(s) for "%s" event, calling...',i.length,e),i.forEach(o=>o.call(this.request,s)))}toFetchApiRequest(){this.logger.info("converting request to a Fetch API Request...");const e=new Request(this.url.href,{method:this.method,headers:this.requestHeaders,credentials:this.request.withCredentials?"include":"same-origin",body:["GET","HEAD"].includes(this.method)?null:this.requestBody}),t=ne(e.headers,{methodCall:([r,s],n)=>{switch(r){case"append":case"set":{const[i,o]=s;this.request.setRequestHeader(i,o);break}case"delete":{const[i]=s;console.warn(`XMLHttpRequest: Cannot remove a "${i}" header from the Fetch API representation of the "${e.method} ${e.url}" request. XMLHttpRequest headers cannot be removed.`);break}}return n()}});return T(e,"headers",t),this.logger.info("converted request to a Fetch API Request!",e),e}};function ie(e){return typeof location>"u"?new URL(e):new URL(e.toString(),location.href)}function T(e,t,r){Reflect.defineProperty(e,t,{writable:!0,enumerable:!0,value:r})}function _t({emitter:e,logger:t}){return new Proxy(globalThis.XMLHttpRequest,{construct(s,n,i){t.info("constructed new XMLHttpRequest");const o=Reflect.construct(s,n,i),a=Object.getOwnPropertyDescriptors(s.prototype);for(const u in a)Reflect.defineProperty(o,u,a[u]);const c=new xt(o,t);return c.onRequest=async function({request:u,requestId:d}){const{interactiveRequest:p,requestController:f}=ve(u);this.logger.info("awaiting mocked response..."),e.once("request",({requestId:E})=>{E===d&&f.responsePromise.state==="pending"&&f.respondWith(void 0)});const w=await J(async()=>{this.logger.info('emitting the "request" event for %s listener(s)...',e.listenerCount("request")),await be(e,"request",{request:p,requestId:d}),this.logger.info('all "request" listeners settled!');const E=await f.responsePromise;return this.logger.info("event.respondWith called with:",E),E});if(w.error){this.logger.info("request listener threw an exception, aborting request...",w.error),c.errorWith(w.error);return}const v=w.data;if(typeof v<"u"){if(this.logger.info("received mocked response: %d %s",v.status,v.statusText),v.type==="error"){this.logger.info("received a network error response, rejecting the request promise..."),c.errorWith(new TypeError("Network error"));return}return c.respondWith(v)}this.logger.info("no mocked response received, performing request as-is...")},c.onResponse=async function({response:u,isMockedResponse:d,request:p,requestId:f}){this.logger.info('emitting the "response" event for %s listener(s)...',e.listenerCount("response")),e.emit("response",{response:u,isMockedResponse:d,request:p,requestId:f})},c.request}})}var Le=class extends Y{constructor(){super(Le.interceptorSymbol)}checkEnvironment(){return typeof globalThis.XMLHttpRequest<"u"}setup(){const e=this.logger.extend("setup");e.info('patching "XMLHttpRequest" module...');const t=globalThis.XMLHttpRequest;P(!t[A],'Failed to patch the "XMLHttpRequest" module: already patched.'),globalThis.XMLHttpRequest=_t({emitter:this.emitter,logger:this.logger}),e.info('native "XMLHttpRequest" module patched!',globalThis.XMLHttpRequest.name),Object.defineProperty(globalThis.XMLHttpRequest,A,{enumerable:!0,configurable:!0,value:!0}),this.subscriptions.push(()=>{Object.defineProperty(globalThis.XMLHttpRequest,A,{value:void 0}),globalThis.XMLHttpRequest=t,e.info('native "XMLHttpRequest" module restored!',globalThis.XMLHttpRequest.name)})}},Ie=Le;Ie.interceptorSymbol=Symbol("xhr");function Mt(e,t){const r=new V({name:"fallback",interceptors:[new Re,new Ie]});return r.on("request",async({request:s,requestId:n})=>{const i=s.clone(),o=await ue(s,n,e.getRequestHandlers(),t,e.emitter,{onMockedResponse(a,{handler:c,parsedResult:u}){t.quiet||e.emitter.once("response:mocked",({response:d})=>{c.log({request:i,response:d,parsedResult:u})})}});o&&s.respondWith(o)}),r.on("response",({response:s,isMockedResponse:n,request:i,requestId:o})=>{e.emitter.emit(n?"response:mocked":"response:bypass",{response:s,request:i,requestId:o})}),r.apply(),r}function Ot(e){return async function(r){e.fallbackInterceptor=Mt(e,r),de({message:"Mocking enabled (fallback mode).",quiet:r.quiet})}}function Ct(e){return function(){var r,s;(r=e.fallbackInterceptor)==null||r.dispose(),ye({quiet:(s=e.startOptions)==null?void 0:s.quiet})}}function Ht(){try{const e=new ReadableStream({start:r=>r.close()});return new MessageChannel().port1.postMessage(e,[e]),!0}catch{return!1}}var Ut=class extends Ae{constructor(...t){super(...t);R(this,"context");R(this,"startHandler",null);R(this,"stopHandler",null);R(this,"listeners");P(!z(),b.formatMessage("Failed to execute `setupWorker` in a non-browser environment. Consider using `setupServer` for Node.js environment instead.")),this.listeners=[],this.context=this.createWorkerContext()}createWorkerContext(){const t={isMockingEnabled:!1,startOptions:null,worker:null,getRequestHandlers:()=>this.handlersController.currentHandlers(),registration:null,requests:new Map,emitter:this.emitter,workerChannel:{on:(r,s)=>{this.context.events.addListener(navigator.serviceWorker,"message",n=>{if(n.source!==this.context.worker)return;const i=n.data;i&&i.type===r&&s(n,i)})},send:r=>{var s;(s=this.context.worker)==null||s.postMessage(r)}},events:{addListener:(r,s,n)=>(r.addEventListener(s,n),this.listeners.push({eventType:s,target:r,callback:n}),()=>{r.removeEventListener(s,n)}),removeAllListeners:()=>{for(const{target:r,eventType:s,callback:n}of this.listeners)r.removeEventListener(s,n);this.listeners=[]},once:r=>{const s=[];return new Promise((n,i)=>{const o=a=>{try{const c=a.data;c.type===r&&n(c)}catch(c){i(c)}};s.push(this.context.events.addListener(navigator.serviceWorker,"message",o),this.context.events.addListener(navigator.serviceWorker,"messageerror",i))}).finally(()=>{s.forEach(n=>n())})}},supports:{serviceWorkerApi:!("serviceWorker"in navigator)||location.protocol==="file:",readableStreamTransfer:Ht()}};return this.startHandler=t.supports.serviceWorkerApi?Ot(t):gt(t),this.stopHandler=t.supports.serviceWorkerApi?Ct(t):mt(t),t}async start(t={}){return t.waitUntilReady===!0&&b.warn('The "waitUntilReady" option has been deprecated. Please remove it from this "worker.start()" call. Follow the recommended Browser integration (https://mswjs.io/docs/integrations/browser) to eliminate any race conditions between the Service Worker registration and any requests made by your application on initial render.'),this.context.startOptions=le(yt,t),await this.startHandler(this.context.startOptions,t)}stop(){super.dispose(),this.context.events.removeAllListeners(),this.context.emitter.removeAllListeners(),this.stopHandler()}};function Wt(...e){return new Ut(...e)}/*! js-cookie v3.0.5 | MIT */function H(e){for(var t=1;t<arguments.length;t++){var r=arguments[t];for(var s in r)e[s]=r[s]}return e}var Dt={read:function(e){return e[0]==='"'&&(e=e.slice(1,-1)),e.replace(/(%[\dA-F]{2})+/gi,decodeURIComponent)},write:function(e){return encodeURIComponent(e).replace(/%(2[346BF]|3[AC-F]|40|5[BDE]|60|7[BCD])/g,decodeURIComponent)}};function K(e,t){function r(n,i,o){if(!(typeof document>"u")){o=H({},t,o),typeof o.expires=="number"&&(o.expires=new Date(Date.now()+o.expires*864e5)),o.expires&&(o.expires=o.expires.toUTCString()),n=encodeURIComponent(n).replace(/%(2[346B]|5E|60|7C)/g,decodeURIComponent).replace(/[()]/g,escape);var a="";for(var c in o)o[c]&&(a+="; "+c,o[c]!==!0&&(a+="="+o[c].split(";")[0]));return document.cookie=n+"="+e.write(i,n)+a}}function s(n){if(!(typeof document>"u"||arguments.length&&!n)){for(var i=document.cookie?document.cookie.split("; "):[],o={},a=0;a<i.length;a++){var c=i[a].split("="),u=c.slice(1).join("=");try{var d=decodeURIComponent(c[0]);if(o[d]=e.read(u,d),n===d)break}catch{}}return n?o[n]:o}}return Object.create({set:r,get:s,remove:function(n,i){r(n,"",H({},i,{expires:-1}))},withAttributes:function(n){return K(this.converter,H({},this.attributes,n))},withConverter:function(n){return K(H({},this.converter,n),this.attributes)}},{attributes:{value:Object.freeze(t)},converter:{value:Object.freeze(e)}})}var W=K(Dt,{path:"/"}),Bt={VITE_APP_URL:"",VITE_APP_API_URL:"",VITE_APP_MOCK_API_PORT:"",VITE_APP_ENABLE_API_MOCKING:"",BASE_URL:"/kocokeeper/",MODE:"production",DEV:!1,PROD:!0,SSR:!1};const $t=e=>(typeof window>"u"?r=>Buffer.from(r,"binary").toString("base64"):window.btoa)(JSON.stringify(e)),Ft=e=>{const t=typeof window>"u"?r=>Buffer.from(r,"base64").toString("binary"):window.atob;return JSON.parse(t(e))},Se=e=>{let t=5381,r=e.length;for(;r;)t=t*33^e.charCodeAt(--r);return String(t>>>0)},y=()=>{const e=Bt.TEST?200:Math.floor(Math.random()*700)+300;return xe(e)},Nt=(e,t)=>{const r={};for(const s in e)t.includes(s)||(r[s]=e[s]);return r},x=e=>Nt(e,["password","iat"]);function ae({email:e,password:t}){const r=h.user.findFirst({where:{email:{equals:e}}});if((r==null?void 0:r.password)===Se(t)){const n=x(r),i=$t(n);return{user:n,jwt:i}}throw new Error("Invalid username or password")}const I="bulletproof_react_app_token";function q(e){try{const t=e[I]||W.get(I);if(!t)return{error:"Unauthorized",user:null};const r=Ft(t),s=h.user.findFirst({where:{id:{equals:r.id}}});return s?{user:x(s)}:{error:"Unauthorized",user:null}}catch{return{error:"Unauthorized",user:null}}}function D(e){if(e.role!=="ADMIN")throw Error("Unauthorized")}const Gt=[g.post(`${m.API_URL}/auth/register`,async({request:e})=>{await y();try{const t=await e.json();if(h.user.findFirst({where:{email:{equals:t.email}}}))return l.json({message:"The user already exists"},{status:400});let s,n;if(t.teamId){if(!h.team.findFirst({where:{id:{equals:t.teamId}}}))return l.json({message:"The team you are trying to join does not exist!"},{status:400});s=t.teamId,n="USER"}else{const o=h.team.create({name:t.teamName??`${t.firstName} Team`});await L("team"),s=o.id,n="ADMIN"}h.user.create({...t,role:n,password:Se(t.password),teamId:s}),await L("user");const i=ae({email:t.email,password:t.password});return W.set(I,i.jwt,{path:"/"}),l.json(i,{headers:{"Set-Cookie":`${I}=${i.jwt}; Path=/;`}})}catch(t){return l.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/auth/login`,async({request:e})=>{await y();try{const t=await e.json(),r=ae(t);return W.set(I,r.jwt,{path:"/"}),l.json(r,{headers:{"Set-Cookie":`${I}=${r.jwt}; Path=/;`}})}catch(t){return l.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/auth/logout`,async()=>(await y(),W.remove(I),l.json({message:"Logged out"},{headers:{"Set-Cookie":`${I}=; Path=/;`}}))),g.get(`${m.API_URL}/auth/me`,async({cookies:e})=>{await y();try{const{user:t}=q(e);return l.json(t)}catch(t){return l.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}})],Xt=[g.get(`${m.API_URL}/comments`,async({request:e,cookies:t})=>{await y();try{const{error:r}=q(t);if(r)return l.json({message:r},{status:401});const n=new URL(e.url).searchParams.get("discussionId")||"",i=h.comment.findMany({where:{discussionId:{equals:n}}}).map(({authorId:o,...a})=>{const c=h.user.findFirst({where:{id:{equals:o}}});return{...a,author:c?x(c):{}}});return l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/comments`,async({request:e,cookies:t})=>{await y();try{const{user:r,error:s}=q(t);if(s)return l.json({message:s},{status:401});const n=await e.json(),i=h.comment.create({authorId:r==null?void 0:r.id,...n});return await L("comment"),l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.delete(`${m.API_URL}/comments/:commentId`,async({params:e,cookies:t})=>{await y();try{const{user:r,error:s}=q(t);if(s)return l.json({message:s},{status:401});const n=e.commentId,i=h.comment.delete({where:{id:{equals:n},...(r==null?void 0:r.role)==="USER"&&{authorId:{equals:r.id}}}});return await L("comment"),l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}})],Vt=[g.get(`${m.API_URL}/discussions`,async({cookies:e})=>{await y();try{const{user:t,error:r}=q(e);if(r)return l.json({message:r},{status:401});const s=h.discussion.findMany({where:{teamId:{equals:t==null?void 0:t.teamId}}}).map(({authorId:n,...i})=>{const o=h.user.findFirst({where:{id:{equals:n}}});return{...i,author:o?x(o):{}}});return l.json(s)}catch(t){return l.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.get(`${m.API_URL}/discussions/:discussionId`,async({params:e,cookies:t})=>{await y();try{const{user:r,error:s}=q(t);if(s)return l.json({message:s},{status:401});const n=e.discussionId,i=h.discussion.findFirst({where:{id:{equals:n},teamId:{equals:r==null?void 0:r.teamId}}});if(!i)return l.json({message:"Discussion not found"},{status:404});const o=h.user.findFirst({where:{id:{equals:i.authorId}}}),a={...i,author:o?x(o):{}};return l.json(a)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.post(`${m.API_URL}/discussions`,async({request:e,cookies:t})=>{await y();try{const{user:r,error:s}=q(t);if(s)return l.json({message:s},{status:401});const n=await e.json();D(r);const i=h.discussion.create({teamId:r==null?void 0:r.teamId,authorId:r==null?void 0:r.id,...n});return await L("discussion"),l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.patch(`${m.API_URL}/discussions/:discussionId`,async({request:e,params:t,cookies:r})=>{await y();try{const{user:s,error:n}=q(r);if(n)return l.json({message:n},{status:401});const i=await e.json(),o=t.discussionId;D(s);const a=h.discussion.update({where:{teamId:{equals:s==null?void 0:s.teamId},id:{equals:o}},data:i});return await L("discussion"),l.json(a)}catch(s){return l.json({message:(s==null?void 0:s.message)||"Server Error"},{status:500})}}),g.delete(`${m.API_URL}/discussions/:discussionId`,async({cookies:e,params:t})=>{await y();try{const{user:r,error:s}=q(e);if(s)return l.json({message:s},{status:401});const n=t.discussionId;D(r);const i=h.discussion.delete({where:{id:{equals:n}}});return await L("discussion"),l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}})],Kt=[g.get(`${m.API_URL}/teams`,async()=>{await y();try{const e=h.team.getAll();return l.json(e)}catch(e){return l.json({message:(e==null?void 0:e.message)||"Server Error"},{status:500})}})],zt=[g.get(`${m.API_URL}/users`,async({cookies:e})=>{await y();try{const{user:t,error:r}=q(e);if(r)return l.json({message:r},{status:401});const s=h.user.findMany({where:{teamId:{equals:t==null?void 0:t.teamId}}}).map(x);return l.json(s)}catch(t){return l.json({message:(t==null?void 0:t.message)||"Server Error"},{status:500})}}),g.patch(`${m.API_URL}/users/profile`,async({request:e,cookies:t})=>{await y();try{const{user:r,error:s}=q(t);if(s)return l.json({message:s},{status:401});const n=await e.json(),i=h.user.update({where:{id:{equals:r==null?void 0:r.id}},data:n});return await L("user"),l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}}),g.delete(`${m.API_URL}/users/:userId`,async({cookies:e,params:t})=>{await y();try{const{user:r,error:s}=q(e);if(s)return l.json({message:s},{status:401});const n=t.userId;D(r);const i=h.user.delete({where:{id:{equals:n},teamId:{equals:r==null?void 0:r.teamId}}});return await L("user"),l.json(i)}catch(r){return l.json({message:(r==null?void 0:r.message)||"Server Error"},{status:500})}})],Jt=[...Gt,...Xt,...Vt,...Kt,...zt,g.get(`${m.API_URL}/healthcheck`,async()=>(await y(),l.json({ok:!0})))],er=Wt(...Jt);export{er as worker};
